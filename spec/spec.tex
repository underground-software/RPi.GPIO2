\documentclass[12pt]{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage[margin=1in]{geometry}
\usepackage{verbatim, hyphenat}

\title{
{python3-libgpiod-rpi 1.0} \\ {Functional and Technical Specification } \\
{\normalsize Revision 2}
}


\author{Joel Savitz}

\begin{document}

\maketitle

\section{Introduction}
\subsection{Purpose}
This document specifies the functional requirements and and technical implementation of python3-libgpiod-rpi. Upon completion and ratification by our group, our development and quality engineering efforts will follow from this document. We will consider this document the upstream authority with respect to our implementation and as such all future changes shall be first specified here and subsequently integrated into our codebase.


\subsection{Scope}
This document specifies the requirements for version 1.0 of python3-libgpiod-rpi.
We may release minor versions in the form of 0.x that partially satisfy this spec.
This document does \textit{not} specify features that extend the \texttt{RPi.GPIO}
interface\footnote{With the exception of \texttt{channel\_valid\_or\_die}(), the addition of which is basically negligible}, in fact, we discourage extensions to the existing API
in version 1.0 unless absolutely necessary.


\subsection{Overview}
We begin with a discussion of the problem and our proposed solution. Then, we define first the high-level functional requirements for version 1.0 and then what each API function should do and not do. Finally, we give a high-level description of the data structures and algorithms used to implement the system.


\subsection{Definitions and Acronyms}

A glossary of terminology and shortand used in this document can be found in table \ref{defs}.

\begin{table}[ht]
\begin{tabular}{|l|l|}
\hline
\multicolumn{1}{|c|}{\textbf{Term}} & \multicolumn{1}{c|}{\textbf{Definition}} \\ \hline
Functional Specification &
\begin{tabular}[c]{@{}l@{}}
A precise specification of the functional requirements \\
that the software must conform to
\end{tabular} \\ \hline
The library &
\begin{tabular}[c]{@{}l@{}}
python3-libgpiod-rpi
\end{tabular} \\ \hline
Raspbian &
\begin{tabular}[c]{@{}l@{}}
A popular Linux distribution designed for the \\
Raspbery Pi device by the Raspberry Pi Foundation
\end{tabular} \\ \hline
Raspberry Pi OS &
\begin{tabular}[c]{@{}l@{}}
The new name for Raspbian announced in 2020
\end{tabular} \\ \hline
GPIO &
\begin{tabular}[c]{@{}l@{}}
General Purpose Input Output, simple  binary  digital \\
logic pins. For more information, search Google.
\end{tabular} \\ \hline
libgpiod &
\begin{tabular}[c]{@{}l@{}}
A generic GPIO library exposing standard Linux 
\\ kernel GPIO functionality
\end{tabular} \\ \hline
\texttt{RPi.GPIO} &
\begin{tabular}[c]{@{}l@{}}
A popular python library for manipulating GPIO pins \\
on the Raspbery Pi using obsolete kernel interfaces
\end{tabular} \\ \hline
python3-libgpiod &
\begin{tabular}[c]{@{}l@{}}
Fedora package that provides bindings for libgpiod \\
use via \texttt{import gpiod}
\end{tabular} \\ \hline
gpiozero & \begin{tabular}[c]{@{}l@{}}
A beginner-friendly zero-boilerplate python library \\
to interface with GPIO devices on the Raspberry Pi
\end{tabular} \\ \hline
GPIO channel or pin &
\begin{tabular}[c]{@{}l@{}}
The number that maps to some GPIO line \\
in terms of either of BCM or BOARD
\end{tabular} \\ \hline
GPIO line &
\begin{tabular}[c]{@{}l@{}}
The object containing data needed to manipulate a \\
physical GPIO output
\end{tabular} \\ \hline
GPIO event &
\begin{tabular}[c]{@{}l@{}}
A change in the voltage on some GPIO pin from either \\
high to low or low to high
\end{tabular} \\ \hline

\end{tabular}
\caption{Definitions and Acronyms used in this document}
\label{defs}
\end{table}

\section{Functional Overview}
This project implements a compatibility layer between \texttt{RPi.GPIO} syntax and libgpiod semantics.

\textbf{Problem}:
\texttt{RPi.GPIO} requires non-standard kernel patches that expose the GPIO registers to userspace via a character device /dev/gpiomem \cite{rpigpio}. As this is not supported by the mainline Linux kernel, any distribution targeting Raspberry Pi devices running the mainline kernel will not be compatible with the \texttt{RPi.GPIO} library. As a large number of tutorials, especially those targeted at beginners, demonstrate use of the RPi's GPIO pins by including \texttt{RPi.GPIO} syntax, this incompatibility limits users to distributions build on a special downstream kernel maintained by the Rapberry Pi foundation. We would like to enable beginners on any Linux distribution by allowing them to follow easily available tutorials.

\textbf{Solution}:
Using the provided module, one will be able to write python code to use the Raspberry Pi's GPIO pins as if they were using the API implemented by \texttt{RPi.GPIO}, but instead using libgpiod's python bindings. libgpiod provides a straightforward interface for interacting with GPIO pins on supported devices via the mainline Linux kernel interface \cite{libgpiod}. The name python3-libgpiod-rpi comes from simple concatenation of ``-rpi'' onto the end of the name of the Fedora package that provides the python bindings for libgpiod, python3-libgpiod.



\section{Functional Requirements for 1.0}

At a high level, our list of functional requirements for 1.0 is relatively short:
\begin{itemize}
    \item API-equivalence and feature-equivalence with \texttt{RPi.GPIO} 0.7.0
    \item Configurationless compatibility with gpiozero \cite{gpiozero}
\end{itemize}

\section{API Functional Specification}

In this section, we define the behavior of our API by careful inspection and interpretation of the \texttt{RPi.GPIO} source code \cite{rpigpio}.
First, we define the core API functions that are accessible via the \texttt{RPi.GPIO} module.
Then, we describe the Object Oriented Pulse-width Modulation interface accessible via the \texttt{RPi.GPIO.PWM} class. Finally, we describe some static data fields and debug functions.

\subsection{Core \texttt{RPi.GPIO} API} \label{coreapi}
 
% TODO
%\noindent
\texttt{RPi.GPIO}.\textbf{add\_event\_callback}(channel, callback)

%\noindent \hfill\begin{minipage}{\dimexpr\textwidth-1cm}


Add a callback function to a channel previously setup for event detection by add\_event\_detect(). When an event is detected by the library, \texttt{callback} will be called after all previously registered callback functions are called first.

%\xdef\tpd{\the\prevdepth}
%\end{minipage}

\textit{parameters}:
\begin{enumerate}
    \item channel --- GPIO channel
    \item callback --- 0-ary callable python object
\end{enumerate}

\textit{exceptions}:
\begin{itemize}
    \item RuntimeError --- Channel not previously setup with add\_event\_detect since last Reset
    \item TypeError --- Parameter \texttt{callback} not callable
    \item ValueError --- Invalid channel
\end{itemize}


\noindent \texttt{RPi.GPIO}.\textbf{add\_event\_detect}(channel, edge, [callback], [bouncetime])

Enable detection of edge events for some GPIO channel.

\textit{parameters}:
\begin{enumerate}
    \item channel --- GPIO channel
    \item edge --- any one of RISING, FALLING, or BOTH to specify types of events to detect
    \item callback (optional) --- 0-ary callable python object
    
    \textit{Default value:} No callback function added
    \item bouncetime (optional) --- Cooldown time in milliseconds for callbacks

    \textit{Default value:} No bouncetime enforced
\end{enumerate}

\textit{exceptions}:
\begin{itemize}
    \item TypeError --- Parameter \texttt{callback} not callable
    \item ValueError --- Invalid channel, edge is not one of RISING, FALLING, or BOTH,  or a negative bouncetime is specified
\end{itemize}

\noindent \texttt{RPi.GPIO}.\textbf{channel\_valid\_or\_die}(channel)

Validate \texttt{channel} using the current numbering mode.

If the channel is valid, the function returns with no effect.
If the channel is invalid, a \texttt{ValueError} exception is raised.

See getmode()/setmode() in section \ref{coreapi} for more information about numbering modes.

\textit{parameters}:
\begin{enumerate}      
    \item channel --- GPIO channel
\end{enumerate}
 
\textit{exceptions}:
\begin{itemize}
    \item ValueError --- Invalid channel
\end{itemize}

\noindent \texttt{RPi.GPIO}.\textbf{cleanup}([channel])

Cleans up library state. Resets all GPIO lines that have been used by this program to INPUT with neither PUD\_UP or PUD\_DOWN set nor event detection enabled on the line. When called with no arguments, this function targets every channel, otherwise, it targets only the channels specified. Subsequent to the actions of cleanup() on a channel, one must pass it to setup() to use it again.

This function is automatically invoked with no parameters
upon terminaton of a python interpreter using this module.

\textit{parameters}:
\begin{enumerate}      
        \item channel (optional) --- individual GPIO channel or list/tuple of GPIO channels
        
        \textit{Default value:} All channels
\end{enumerate}
 
\textit{exceptions}:
\begin{itemize}
    \item ValueError --- Invalid channel
\end{itemize}

\noindent \texttt{RPi.GPIO}.\textbf{event\_detected}(channel)

Returns True if an edge has occurred on a given GPIO at the time of call. Otherwise, returns False. This function does not block and will always return False unless add\_event\_detect() is called on \texttt{channel} first.


\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
\end{enumerate}
 
 
\textit{exceptions}:
\begin{itemize}
    \item ValueError --- Invalid channel
\end{itemize}

\noindent \texttt{RPi.GPIO}.\textbf{getmode}()
    
Get the numbering mode in use for GPIO channels. Returns one of BOARD, BCM or None

\textit{exceptions}:
\begin{itemize}
    \item RuntimeError --- Module was not imported correctly
\end{itemize}


\noindent \texttt{RPi.GPIO}.\textbf{gpio\_function}(channel)
        
Get the GPIO function constant corresponding to \texttt{channel}. Returns one of IN, OUT, PWM, SERIAL, I2C, or SPI.
        
\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
\end{enumerate}
 
 
\textit{exceptions}:
\begin{itemize}
    \item ValueError --- Invalid channel
\end{itemize}

\noindent \texttt{RPi.GPIO}.\textbf{input}(channel)
        
Get the current value of the GPIO line specified by \texttt{channel}. Returns one of HIGH=1 or LOW=0. Direction of \texttt{channel} must be one of INPUT or OUTPUT.
        
\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
\end{enumerate}
 
 
\textit{exceptions}:
\begin{itemize}
    \item ValueError --- Invalid channel
    \item RuntimeError --- direction of \texttt{channel} not one of INPUT or OUTPUT
\end{itemize}


\noindent \texttt{RPi.GPIO}.\textbf{output}(channel)
        
Set the value of an individual GPIO channel or a list/tuple of GPIO channels with an individual value or a list/tuple of values respectively.
One may specify multiple channels and a single value for each channel to be set to the same value.
        
\textit{parameters}:
\begin{enumerate}      
        \item channel --- Individual GPIO channel or list/tuple of GPIO channels
        \item value --- Individual value or list/tuple of values that are one of LOW=0 or HIGH=1
\end{enumerate}
 
 
\textit{exceptions}:
\begin{itemize}
    \item ValueError --- Invalid channel(s) or invalid values(s)
    \item RuntimeError --- Number of channels specified differs from number of values provided or the GPIO channel has not been setup as an output
\end{itemize}



\noindent \texttt{RPi.GPIO}.\textbf{remove\_event\_detect}(channel)
        
Disable and clean up edge event detection configured on a particular GPIO channel. This removes all callback functions saved for that channel.
        
\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
\end{enumerate}


\textit{exceptions}:
\begin{itemize}
    \item ValueError --- Invalid channel
\end{itemize}


\noindent \texttt{RPi.GPIO}.\textbf{setmode}(mode)

Set up numbering mode to use for channels. Mode is one of BOARD or BCM, where BOARD specifies use of Raspberry Pi board numbers and BCM specifies use of Broadcom GPIO 00..nn numbers
        
\textit{parameters}:
\begin{enumerate}      
        \item mode --- One of BOARD or BCM
\end{enumerate}
 
 
\textit{exceptions}:
\begin{itemize}
    \item ValueError --- Invalid mode or setmode() already called once since last call to Reset
    \item RuntimeError --- Module was not imported correctly 
\end{itemize}

\noindent \texttt{RPi.GPIO}.\textbf{setup}(channel)
 
 
Set up an individual GPIO channel or list/tuple of GPIO channels given a direction and (optionally) a bias (e.g. PUD\_UP/PUD\_DOWN)

\begin{enumerate}      
        \item channel --- GPIO channel
        \item direction --- One of IN or OUT
        \item pull\_up\_down (optional) --- Either the default value PUD\_OFF or one of PUD\_UP, PUD\_DOWN, or PUD\_DISABLE
        \item initial (optional) --- Initial channel value (only allowed for output)
\end{enumerate}
 
 
\textit{exceptions}:
\begin{itemize}
    \item ValueError --- Invalid channel(s), direction not one of IN or OUT, bias specified for OUT direction, initial pin value specified for IN direction
    \item RuntimeError --- Module was not imported correctly 
\end{itemize}


\noindent \texttt{RPi.GPIO}.\textbf{setwarnings}(value)
        
Enable or disable warning messages. Use True to enable and False to disable.
        
\textit{parameters}:
\begin{enumerate}      
        \item value --- A boolean
\end{enumerate}
 
 
\textit{exceptions}:
\begin{itemize}
    \item RuntimeError --- Module was not imported correctly 
\end{itemize}

\noindent \texttt{RPi.GPIO}.\textbf{wait\_for\_edge}(channel, edge, [bouncetime], [timeout])

[BLOCKS] Wait for an edge event of type \texttt{edge} to take place on \texttt{channel}. Disables python's Global Interpreter Lock while blocking. A negative timeout value will cause the program to block indefinitely waiting for an edge event. A timeout value of zero will prevent the program from blocking entirely.

If an event is detected and if the implication holds that a bouncetime is specified implies that any one of the following is true: 
\begin{enumerate}
    \item The difference between the current time and the time at which this event previously occurred
    \item This function, \texttt{line\_event\_wait} has never been called before on this channel
    \item The time at which this event last occurred is later than the current time \footnote{Yeah I don't really understand this one either, for more information refer to \texttt{The RPi.GPIO 0.7.0 Source Code, source/event\_gpio.c:579}\cite{rpigpio}}.
\end{enumerate}

Then, the 0-ary callable objects stored in the list \texttt{\_State.lines[channel].callbacks} will be serially invoked. If one subsequently invokes \texttt{event\_dected(channel)}, the event detected by this function will \textit{not} be reported.

Returns \texttt{channel} if any event is detected, otherwise returns None.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
        \item edge --- any one of RISING, FALLING, or BOTH to specify types of events to wait for
        \item bouncetime (optional) --- Cooldown time in milliseconds for callbacks
        
        \textit{Default value:} No bouncetime enforced
        \item timeout (optional) --- time in milliseconds to wait before quitting
        
        \textit{Default value}: The call will block indefinitely
\end{enumerate}
 
 
\textit{exceptions}:
\begin{itemize}
    \item ValueError --- Invalid channel, invalid edge, non-positive bouncetime, or  non-positive timeout specified
    %\item RuntimeError --- GPIO channel not yet setup as an input
    % we exclude the above RPi.GPIO exception from this specification
    % because we allow this by design and set the line_mode behind the scenes
    % TODO: return to this issue
    %
    % Also, should this spec include OSError exceptions we introduce?
    % \item RuntimeError --- edge detection is already configured on this channel
    % Yeah you're allowed to do that ^^ with this library as well, unlike the original RPi.GPIO
\end{itemize}

\subsection{Class \texttt{RPi.GPIO.PWM}} \label{pwm}
    
\texttt{RPi.GPIO.PWM} is a Pulse-width Modulation (PwM) class. Object methods follow.

\medskip \medskip

\noindent \texttt{RPi.GPIO.PWM}.\textbf{ChageDutyCycle}(dutycycle)
        
Change the duty cycle of the PwM channel to \texttt{dutycycle}
        
\textit{parameters}:
\begin{enumerate}      
        \item dutycycle --- percentage of pulse period to output high voltage
\end{enumerate}
 
 
\textit{exceptions}:
\begin{itemize}
    \item ValueError --- Invalid duty cycle
\end{itemize}

\noindent \texttt{RPi.GPIO.PWM}.\textbf{ChangeFrequency}(frequency)
        
Change the frequency the PwM channel to \texttt{frequency}
        
\textit{parameters}:
\begin{enumerate}      
        \item frequency --- pulse periodicity in hz
\end{enumerate}
 
 
\textit{exceptions}:
\begin{itemize}
    \item ValueError --- Invalid frequency value
\end{itemize}

\noindent \texttt{RPi.GPIO.PWM}.\textbf{\_\_init\_\_}(channel, frequency)
        
Initialize a new PwM object. Commonly invoked via:

\texttt{RPi.GPIO.PWM(channel, frequency)}

\textit{parameters}:
\begin{enumerate}
        \item channel --- GPIO channel
        \item frequency --- A positive float value
\end{enumerate}
 
 
\textit{exceptions}:
\begin{itemize}
    \item ValueError --- Invalid frequency value
    \item RuntimeError --- PwM already setup on \texttt{channel}
    % or channel not setup in direction OUT (but should this be in the spec?
    % TODO
\end{itemize}

\noindent \texttt{RPi.GPIO.PWM}.\textbf{start}(dutycycle)
        
Start software PwM on the channel specified in \texttt{\_\_init\_\_}.

\textit{parameters}:
\begin{enumerate}      
        \item dutycycle --- A value between 0.0 and 100.0
\end{enumerate}
 
 
\textit{exceptions}:
\begin{itemize}
    \item ValueError --- Invalid duty cycle
\end{itemize}

\noindent \texttt{RPi.GPIO.PWM}.\textbf{stop}()
        
Stop software PwM on the channel specified in \texttt{\_\_init\_\_}.

\medskip \medskip

\subsection{Data}

\noindent \texttt{RPi.GPIO}.\textbf{BCM}

Some constant representing BCM chip numbering mode, the numbering of the channels according to the Broadcom specification

\noindent \texttt{RPi.GPIO}.\textbf{BOARD}

Some constant representing BOARD chip numbering mode, the numbering of the channels according to the Raspberry Pi specification

\noindent \texttt{RPi.GPIO}.\textbf{BOTH}

Some constant representing edge event detection of both rising edge and falling edge events

\noindent \texttt{RPi.GPIO}.\textbf{FALLING}

Some constant representing falling edge event detection only

\noindent \texttt{RPi.GPIO}.\textbf{HARD\_PWM}

Some constant representing that a GPIO channel is capable of supporting hardware PwM

\noindent \texttt{RPi.GPIO}.\textbf{HIGH}

Some nonzero constant representing a high-power state on a GPIO channel.
Can be used to specify active state of a channel.


\noindent \texttt{RPi.GPIO}.\textbf{I2C}

Some constant representing that a GPIO channel is capable of supporting the i2c protocol

\noindent \texttt{RPi.GPIO}.\textbf{IN}

Some constant representing the input direction of a GPIO channel

\noindent \texttt{RPi.GPIO}.\textbf{LOW}

A constant zero representing a low-power state on a GPIO channel.
Can be used to specify active state of a channel.

\noindent \texttt{RPi.GPIO}.\textbf{OUT}

Some constant representing the output direction of a GPIO channel

\noindent \texttt{RPi.GPIO}.\textbf{PUD\_DISABLE}

Some constant representing the explicit choice to disable pull-up or pull-down resistors.

\noindent \texttt{RPi.GPIO}.\textbf{PUD\_DOWN}

Some constant representing a pull-down resistor on a GPIO channel.

\noindent \texttt{RPi.GPIO}.\textbf{PUD\_OFF}

Some constant representing the lack of a pull-up or pull-down resistor on a GPIO channel.
% TODO: come back to this

\noindent \texttt{RPi.GPIO}.\textbf{PUD\_UP}

Some constant representing a pull-up resistor on a GPIO channel.

\noindent \texttt{RPi.GPIO}.\textbf{RISING}

Some constant representing rising edge event detection only


\noindent \texttt{RPi.GPIO}.\textbf{RPI\_INFO}

A dictionary of the following key/value pair structure:
\begin{itemize}
    \item ``MANUFACTURER'': Board manufacturer
    \item ``P1\_REVISION'': Secondary revision number
    \item ``PROCESSOR'': CPU information
    \item ``RAM'': Total system RAM
    \item ``REVISION'': Primary revision number
    \item ``TYPE'': Board model name string
\end{itemize}


\noindent \texttt{RPi.GPIO}.\textbf{RPI\_REVISION}

The major version of this Raspberry Pi device.

\noindent \texttt{RPi.GPIO}.\textbf{SERIAL}

Some constant representing that a GPIO channel is capable of supporting the serial protocol


\noindent \texttt{RPi.GPIO}.\textbf{SPI}

Some constant representing that a GPIO channel is capable of supporting the spi protocol

\noindent \texttt{RPi.GPIO}.\textbf{UNKNOWN}

Some constant representing unknown information


\noindent \texttt{RPi.GPIO}.\textbf{VERSION}

The version of this library.
% TODO: should this actually be the latest supported version of the RPi.GPIO API?

\medskip \medskip

\subsection{Debug}

What follows are a few functions that may be useful for debugging this library.

\noindent \texttt{RPi.GPIO}\_DEVEL.\textbf{Reset}()
        
Cleanup and re-initialize the library as if it was just imported.

\noindent \texttt{RPi.GPIO}\_DEVEL.\textbf{setdebuginfo}(value)
        
Enable or disable verbose debug messages. Use True to enable and False to disable.

\textit{parameters}:
\begin{enumerate}      
        \item value --- A boolean
\end{enumerate}
 

\textit{exceptions}:
\begin{itemize}
    \item RuntimeError --- Module was not imported correctly 
\end{itemize}

\section{High Level Technical Specification}

In this section, we discuss the implementation design of python3-libgpiod-rpi. In contrast to the style of the functional specification where data and procedures were listed in alphabetical order, we will organize lists in this section in order to best reflect the underlying design.

\subsection{Architecture Overview}

We aim to translate \texttt{RPi.GPIO} API calls to their libgpiod equivalents. In general, the way this library modulates the user's request for an \texttt{RPi.GPIO} action is through a shared state object containing a python \texttt{gpiod.Chip} object and a list of the 54 \texttt{gpio.Line} objects. The user makes calls to our API functions which handle input validation and these functions make calls to our internal interface functions, those modifying the \texttt{Chip} object being prefixed by \texttt{chip\_} and those modifying Line objects being prefixed by \texttt{line\_}. These internal interface functions modularize the library by separating API call validation from internal state changes and associated locking.

As much as possible, we try to transparently manipulate channel state as specified by the \texttt{RPi.GPIO} source code, but due to a lack of exact correspondence, we introduce line mode constants that represent the states that a particular GPIO channel can be in. We specify the meaning of these constants below.

Software Pulse-width Modulation is implemented on top of the core API.
% TODO: validate this
We essentially make repeated calls to \texttt{GPIO.output(channel)} corresponding appropriately to the period and duty cycle.

Event detection is done by running a poll thread using python's
built-in threading class, \texttt{threading.Thread}.
Since multiple active threads may try to write to the library state,
we implement mutual exclusion for critical sections on a per-GPIO channel basis,
with each \texttt{gpiod.Line} object having an associated lock of type
\texttt{threading.lock}. These locks are intended to be used via
the \texttt{begin\_critical\_section(channel, msg)} and
\sloppy
\texttt{end\_critical\_section(channel, msg)} interface
primitives. Some internal interface functions have locking and non-locking versions.
This is indicated via a \texttt{\_lock} suffix appended to the function identifier.

\subsection{Data Design: Class \_State} \label{class_state}

The top-level container for the internal state of the library. Intended to be accessed at the class level as a global shared state as if one were accessing a C struct at global scope. 

\medskip

\noindent \_State.\textbf{mode}

One of UNKNOWN, BCM, or BOARD. Represents the current line numbering mode.

\textit{Default value:} UNKNOWN

\noindent \_State.\textbf{warnings}

Either True or False. Determines whether warning messages are printed to \texttt{stdout} or suppressed.

\textit{Default value:} True

\noindent \_State.\textbf{debuginfo}

Either True or False. Determines whether debug messages unique to this library are printed to \texttt{stdout} or suppressed.

\textit{Default value:} False

\noindent \_State.\textbf{chip}

The instance of class \texttt{gpiod.Chip} containing the GPIO channels provided by the \texttt{RPi.GPIO} API.

\textit{Default value:} \texttt{gpiod.Chip("gpiochip0")}

\noindent \_State.\textbf{event\_ls}

A list of the channels on which events have recently occurred. Will be invariantly empty until event detection is setup on one or more channels.

\textit{Default value:} Empty List

\noindent \_State.\textbf{lines}

A list of \texttt{\_Line} objects corresponding to each GPIO channel. \texttt{\_Line} objects are internal to this library and contain corresponding \texttt{gpiod.Line} objects and associated data.

\textit{Default value:} \texttt{[\_Line(channel) for channel in range(chip\_get\_num\_lines())]}

\subsection{Data Design: Class \_Line}

The internal representation of a GPIO line corresponding to a particular GPIO channel.

\medskip

\noindent \_Line.\textbf{\_\_init\_\_}(channel)
        
Initialize a new \_Line object. Invoked by \texttt{Reset}.

\textit{parameters}:
\begin{enumerate}
        \item channel --- GPIO channel
\end{enumerate}
 
\noindent \_Line.\textbf{thread\_start}(target\_type, args)

[LOCK REQUIRED] Start a new thread on this channel to either poll for events or do pulse-width modulation.
Returns True if a thread is sucessfully started and False otherwise.

\textit{parameters}:
\begin{enumerate}
	\item target\_type --- one of either \texttt{\_line\_thread\_poll} or \texttt{\_line\_thread\_pwm} to specify thread type
	\item args --- a tuple of arguments to pass to the entry point for the new thread
\end{enumerate}

\noindent \_Line.\textbf{thread\_stop}()

[LOCK REQUIRED] Stop the thread running on this channel if one exists.

\noindent \_Line.\textbf{cleanup}()
      
[LOCK REQUIRED] Reset the internal state of the object to initial state. Kills the channel's poll thread if one is running. Clears the list of callbacks. Sets line mode to \texttt{\_line\_mode\_none}.

\noindent \_Line.\textbf{mode\_request}(mode, flags)

Request for \texttt{libgpiod} to execute the syscall to get permissions to access \texttt{self.channel}.

\textit{parameters}:
\begin{enumerate}
        \item mode --- the desired libgpiod mode
        \item flags --- flags specified configuration (e.g. pull up/pull down resistors)
\end{enumerate}

\noindent \_Line.\textbf{channel}

The GPIO channel corresponding to this line.

\textit{Default value:} An integer passed to \texttt{\_\_init\_\_} via \texttt{Reset()}.
See \texttt{\_State.lines} in section \ref{class_state}.

\noindent \_Line.\textbf{line}

The \texttt{gpiod.Line} object corresponding to this channel

\textit{Default value:} \texttt{gpiod.Chip.get\_line(self.channel)}

\noindent \_Line.\textbf{mode}

The current line mode of the GPIO channel. See section \ref{linemodes} for more on line modes.

\textit{Default value:} \texttt{\_line\_mode\_none}

\noindent \_Line.\textbf{lock}

A locking primitive of type \texttt{threading.Lock}.

Used internally by the locking interface primitives
\texttt{begin\_critical\_section(channel, msg)} and
\texttt{end\_critical\_section(channel, msg)}.

\textit{Default value:} \texttt{threading.Lock()}

\noindent \_Line.\textbf{thread}

An entry of type \texttt{\_LineThread} used to represent a poll thread that checks for edge events on a pin.

\textit{Default value:} None

\noindent \_Line.\textbf{callbacks}

A list of callable objects that are sequentially invoked upon edge event detection on \texttt{self.channel}.

\textit{Default value:} Empty List

\noindent \_Line.\textbf{timestamp}

A timestamp (from \texttt{time.time()}) of the last edge event detected on that channel. Used to enforce bounce timeout for callbacks on a channel.

\textit{Default value:} None


\subsection{Data Design: Class \_LineThread}

A subclass of \texttt{threading.Thread} with basic stopability. 

\medskip

\noindent \_LineThread.\textbf{\_\_init\_\_}(channel, target\_type, args)
        
Create a new instance of this class on \texttt{channel} that will call \texttt{target(*args)} when the line thread is started via \texttt{line\_start\_poll} or \texttt{line\_start\_pwm}

\textit{parameters}:
\begin{enumerate}
        \item channel --- GPIO channel
	\item target\_type --- one of either \texttt{\_line\_thread\_poll} or \texttt{\_line\_thread\_pwm} to specify thread type
        \item args --- arguments that will be passed to target at invocation
\end{enumerate}
 

\noindent \_LineThread.\textbf{kill}()

[LOCK REQUIRED] Stop a \_LineThread's thread by setting the stop event and joining the thread until completion.
The lock is dropped temporarily during the call to join() to allow the thread to finish its last iteration.

\subsection{The  \texttt{channel\_} and \texttt{chip\_} interfaces}

This section defines the internal interface functions used to implement operations at the \texttt{gpiod.Chip} level and validation of channel numbers. External exposure of these functions is undefined behavior.

\medskip

\noindent channel\_\textbf{fix\_and\_validate}(channel)

Validate \texttt{channel} using the current numbering mode.
See getmode()/setmode() in section \ref{coreapi} for more information about numbering modes.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
\end{enumerate}
 
 
\textit{exceptions}:
\begin{itemize}
    \item ValueError --- Invalid channel in current numbering mode
\end{itemize}

\noindent chip\_\textbf{close}()

\noindent chip\_\textbf{close\_if\_open}()

Close the file descriptor associated with the internal \texttt{gpiod.Chip} object and remove references to the object from \texttt{\_State}. The former name will always attempt these operations. The latter name will perform these operations only if \texttt{\_State.chip} is not None. Internally, we only call the latter except from the latter itself.

\noindent chip\_\textbf{destroy}

[LOCKS ALL CHANNELS] Acquire a lock on every channel and then call \texttt{chip\_close\_if\_open()}.

\noindent chip\_\textbf{get\_num\_lines}()

Returns the number of GPIO lines on the chip. Used to initialize the list of \texttt{\_Line} objects held by \texttt{\_State}. See section \ref{class_state} for more information.

\noindent chip\_\textbf{init}()

\noindent chip\_\textbf{init\_if\_needed}()

Initialize the \texttt{gpiod.Chip} object held by \texttt{\_State.chip}. The former name performs these operations directly. The latter name performs these operations only if \texttt{\_State.chip} is not None.

\textit{exceptions}:
\begin{itemize}
    \item PermissionError --- Unable to open file ``/dev/gpiochip0'', perhaps because script was not run as root.
\end{itemize}

\noindent chip\_\textbf{is\_open}()

Returns the truth value of whether the chip has been initialized.
True if yes, False if no.

\subsection{The \texttt{line\_} interface}

This section defines the internal interface functions used to implement operations at the \texttt{gpiod.Line} level. External exposure of these functions is undefined behavior.

\medskip

\noindent line\_\textbf{add\_callback}(channel, callback)

[LOCKS channel] Append a callable function to the list of callable python objects stored in \texttt{\_State.lines[channel].callbacks}. Upon the next edge event detected on this channel, \texttt{callback} will be invoked after the other callback functions are invoked. 

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
        \item callback --- A 0-ary callable object
\end{enumerate}

\noindent line\_\textbf{do\_poll}(channel, bouncetime, timeout)

[LOCKS channel] Execute the main loop of a poll thread while the thread has not been killed. Guaranteed to drop the lock for at least ten milliseconds per iteration.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
        \item bouncetime --- cooldown time in milliseconds for invoking the callback functions
        \item timeout --- time in milliseconds to wait per loop before giving up
\end{enumerate}

\noindent line\_\textbf{event\_wait}(channel, bouncetime, timeout, track)

\noindent line\_\textbf{event\_wait\_lock}(channel, bouncetime, track)

[first: LOCK REQUIRED, second: LOCKS channel]
Wait for an edge event of type previously specified in edge event detection setup. Calls \texttt{gpiod.Line.event\_wait()}. Returns the channel number if an event occurred and returns None otherwise. 

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
        \item bouncetime --- cooldown time in milliseconds for invoking the callback functions
        \item timeout --- time in milliseconds to wait per loop before giving up
        \item track --- Boolean value, the truth of which determines whether the event will subsequently be reported by \texttt{RPi.GPIO.event\_detected(channel)}.
\end{enumerate}

\noindent line\_\textbf{get\_active\_state}(channel)

Returns \texttt{gpiod.Line.active\_state(channel)}.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
\end{enumerate}

\noindent line\_\textbf{get\_bias}(channel)

Returns \texttt{gpiod.Line.bias(channel)}.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
\end{enumerate}

\noindent line\_\textbf{get\_flags}(channel)

Returns a bitwise-and of all return values of functions that get libgpiod request flags.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
\end{enumerate}

\noindent line\_\textbf{get\_mode}(channel)

Returns \texttt{\_State.lines[channel].mode}

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
\end{enumerate}

\noindent line\_\textbf{get\_unique\_name}(channel)

Returns some string such that no other call to this function with a different value of channel will produce this string.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
\end{enumerate}

\noindent line\_\textbf{get\_value}(channel)

Calls \texttt{gpiod.Line.get\_value()} on \texttt{channel}.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
\end{enumerate}


\noindent line\_\textbf{is\_active}(channel)

This functions returns a Boolean that represents the authority on whether a channel is in use by this library. A channel is defined to be active if it has line mode other than \texttt{\_line\_mode\_none}.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
\end{enumerate}

\noindent line\_\textbf{is\_pwm}(channel)

Returns True if a \texttt{GPIO.PWM} object has been created on \texttt{channel}, otherwise returns False.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
        \item dutycycle --- percentage of pulse period to output high voltage
\end{enumerate}

\noindent line\_\textbf{kill\_poll}(channel)

\noindent line\_\textbf{kill\_poll\_lock}(channel)

[first: LOCK REQUIRED, second: LOCKS channel]
Stos poll thread running on \texttt{channel} by calling \texttt{\_PollThread.kill()}. Remove the reference to that \_PollThread object from the parent \_Line. Do not return until the operation is complete.


\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
\end{enumerate}

\noindent line\_\textbf{poll\_start}(channel, edge, callback, bouncetime)

[LOCKS channel] Kick off a new poll thread from the main thread.
Creates and starts new \_PollThread. Adds any specified callbacks to \texttt{\_State.lines[channel].callbacks}. 

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
        \item edge --- any one of RISING, FALLING, or BOTH to specify types of events poll for
        \item callback --- A 0-ary callable object
        \item bouncetime --- cooldown time in milliseconds for invoking the callback functions
\end{enumerate}

\noindent line\_\textbf{pwm\_set\_dutycycle}(channel, dutycycle)

\noindent line\_\textbf{pwm\_set\_dutycycl\_lock}(channel, dutycycle)

[first: LOCK REQUIRED, second: LOCKS channel]
Set the dutycycle value for pulse-width modulation.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
        \item dutycycle --- percentage of pulse period to output high voltage
\end{enumerate}

\noindent line\_\textbf{pwm\_set\_frequency}(channel, frequency)

[LOCKS channel] Set the pulse frequency value for pulse-width modulation.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
        \item frequency --- pulse periodicity in hz
\end{enumerate}

\noindent line\_\textbf{pwm\_start}(channel, dutycycle)

[LOCKS channel] Start pulse-with modulation on \texttt{channel}.
Returns true if successful and false otherwise.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
        \item dutycycle --- percentage of pulse period to output high voltage
\end{enumerate}

\noindent line\_\textbf{pwm\_stop}(channel)

Stop a pulse-width modulation running on \texttt{channel} if it exists.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
\end{enumerate}

\noindent line\_\textbf{set\_flags}(channel, flags)

[LOCKS channel]
Set the flags on \texttt{channel} to \texttt{flags} via \texttt{gpiod.Line.set\_flags()}. Used to set line bias and line active\_state.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
        \item flags --- the new flags value to set
\end{enumerate}

\noindent line\_\textbf{set\_mode}(channel, mode, flags)

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
        \item mode --- A valid line mode. See section \ref{linemodes}.
        \item flags (optional) --- the new flags value to set.
        
        \textit{Default value:} $0$
\end{enumerate}

\noindent line\_\textbf{set\_value}(channel, value)

Calls \texttt{gpiod.Line.set\_value(value)} on \texttt{channel}.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
        \item value --- new value for GPIO channel
\end{enumerate}

\noindent line\_\textbf{thread\_should\_die}(channel)

Return the value \texttt{\_State.lines[channel].thread.killswitch.is\_set()}. Used by a line thread when it considers suicide.

\textit{parameters}:
\begin{enumerate}      
        \item channel --- GPIO channel
\end{enumerate}


\subsection{Data Design: Line Modes and Line threads} \label{linemodes}

The following constants are internal to the library and their external exposure is undefined. The reason for the distinction between ``Values'' and ``Events'' mode types is that the underlying \texttt{ioctl(2)} syscalls made by \texttt{libgpiod} actually request different access permissions for that GPIO channel depending on this choice.

\noindent \textbf{\_line\_mode\_none}

The default line mode. This line is not accessible and should not be used in this mode.

\noindent \textbf{\_line\_mode\_in}

Values input mode. This line is setup to get the value of the pin as input.

\noindent \textbf{\_line\_mode\_out}

Values output mode. This line is setup to set the value of the pin as output.

\noindent \textbf{\_line\_mode\_falling}

Events mode for rising edge events.

\noindent \textbf{\_line\_mode\_rising}

Events mode for rising edge events.

\noindent \textbf{\_line\_mode\_both}

Events mode for both rising and falling edge events. Detects all events.

\noindent \textbf{\_line\_mode\_as\_is}

Events as-is mode. As of yet undefined.

\noindent \textbf{\_line\_thread\_poll}

A thread type to represent the lack of a thread

\noindent \textbf{\_line\_thread\_poll}

A thread type that will poll for events on a channel

\noindent \textbf{\_line\_thread\_pwm}

A thread type that will execute software pulse-width modulation on a channel

\section{Requirements Summary for version 1.0}

\noindent \textbf{Functional:}
\begin{itemize}
    \item API-equivalence and feature-equivalence with \texttt{RPi.GPIO} 0.7.0 \cite{rpigpio}
    \item Configurationless compatibility with gpiozero \cite{gpiozero}
\end{itemize}

\noindent \textbf{Business:}
\begin{itemize}
    \item \texttt{RPi.GPIO} API support on Fedora Linux
\end{itemize}

\bibliographystyle{acm}

\bibliography{sources}

\end{document}
